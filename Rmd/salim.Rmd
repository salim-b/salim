---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "download_url",
                                 "filename",
                                 "id",
                                 "name",
                                 "version_nr"))
```

# DATA

Note that although the datasets defined below are saved as "internal data" in `R/sysdata.rda`, they are still exported later on, something not explicitly
mentioned in the book [R Packages](https://r-pkgs.org/data.html#data-data) (and maybe a CRAN violation?).

## Define data

### Regular expression rules for spelling normalization

These rules are tailored to projects of the [Centre for Democracy Studies Aarau (ZDA)](https://www.zdaarau.ch/).

```{r, purl = FALSE}
regex_spelling_normalization <-
  tibble::tibble(id = character(),
                 category = character(),
                 purpose = character(),
                 pattern = list(),
                 replacement = character()) %>%
  # harmonize spelling
  tibble::add_row(id = "title_fa",
                  category = "harmonize_spelling",
                  purpose = "harmonize spelling of the [_FOKUS Aargau_](https://fokus.ag/) project title",
                  pattern = list("Fokus(?=[ -]Aargau)"),
                  replacement = "FOKUS") %>%
  tibble::add_row(id = "title_smartvote",
                  category = "harmonize_spelling",
                  purpose = "harmonize spelling of the [_smartvote_](https://smartvote.ch/) VAA",
                  pattern = list("\\bSmartvote\\b"),
                  replacement = "smartvote")
```

## Save data to `R/sysdata.rda`

```{r, purl = FALSE}
usethis::use_data(regex_spelling_normalization,
                  internal = FALSE,
                  overwrite = TRUE,
                  compress = "xz",
                  version = 3L)
```

## Document data

```{r}
#' Regular expression patterns and replacements for spelling normalization
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`yay::regex_text_normalization`] [`yay::regex_file_normalization`] [yay::str_normalize()]
#'
#' @examples
#' # unnest the pattern column
#' tidyr::unnest_longer(data = regex_spelling_normalization,
#'                      col = pattern)
"regex_spelling_normalization"
```

# Spoken language

## Multi-language

### Convert an integer into spelled abbreviated English or German rank

```{r}
#' Convert an integer into spelled abbreviated English or German rank
#'
#' @param x An integer scalar or something coercible to.
#' @param lang The language to write the rank in.
#'
#' @return A character scalar.
#' @family spoken
#' @export
rank_nr <- function(x,
                    lang = c("en", "de")) {
  
  lang <- rlang::arg_match(lang)
  result <- "?"
  
  if (length(x)) {
    
    if (lang == "de") {
      result <- switch(EXPR = as.character(as.integer(x)),
                       "1" = "erste",
                       "2" = "zweite",
                       "3" = "dritte",
                       "4" = "vierte",
                       "5" = "f\u00fcnfte",
                       "6" = "sechste",
                       "7" = "siebte",
                       "8" = "achte",
                       "9" = "neunte",
                       "?")
      
    } else if (lang == "en") {
      result <- switch(EXPR = as.character(as.integer(x)),
                       "1" = "1st",
                       "2" = "2nd",
                       "3" = "3rd",
                       "4" = "4th",
                       "5" = "5th",
                       "6" = "6th",
                       "7" = "7th",
                       "8" = "8th",
                       "9" = "9th",
                       "?")
    }
  }
  
  result
}
```

### Write out a count

Caveats:

-   German is only covered from 0 to 9.

-   No support for grammatical gender -- articles of definite descriptors are always feminine.

```{r}
#' Write out a count
#'
#' @param n The count to write out in letters. A non-negative integer scalar.
#' @param lang The language to write out `n` in.
#' @param use_singular Use a definite descriptor for `n = 0` and `n = 1` instead of the indistinct number. A logical scalar.
#' @param use_dual Use a definite descriptor for `n = 2` instead of the indistinct number. A logical scalar.
#' @param strip_article Strip the definite article from the definite descriptors. Only relevant if at least one of `use_singular` or `use_dual` is `TRUE`. A
#'   logical scalar.
#'
#' @return A character scalar.
#' @family spoken
#' @export
write_out_n <- function(n,
                        lang = c("en", "de"),
                        use_singular = FALSE,
                        use_dual = FALSE,
                        strip_article = use_dual) {
  
  n %<>% checkmate::assert_count() %>% as.character()
  lang <- rlang::arg_match(lang)
  checkmate::assert_flag(use_singular)
  checkmate::assert_flag(use_dual)
  checkmate::assert_flag(strip_article)
  
  if (lang == "en") {
    
    result <- switch(EXPR = n,
                     `0` = dplyr::if_else(use_singular,
                                          "no",
                                          "zero"),
                     `1` = dplyr::if_else(use_singular,
                                          "the",
                                          "one"),
                     `2` = dplyr::if_else(use_dual,
                                          "the two",
                                          "two"),
                     xfun::numbers_to_words(as.integer(n)))
    
  } else if (lang == "de") {
    
    result <- switch(EXPR = n,
                     `0` = dplyr::if_else(use_singular,
                                          "keine",
                                          "null"),
                     `1` = dplyr::if_else(use_singular,
                                          "die",
                                          "ein"),
                     `2` = dplyr::if_else(use_dual,
                                          "die beiden",
                                          "zwei"),
                     `3` = "drei",
                     `4` = "vier",
                     `5` = "f\u00fcnf",
                     `6` = "sechs",
                     `7` = "sieben",
                     `8` = "acht",
                     `9` = "neun")
  }
  
  result %>% purrr::when(strip_article ~ stringr::str_remove(string = .,
                                                             pattern = switch(EXPR = lang,
                                                                              de = "^[Dd]ie ?",
                                                                              en = "^[Tt]he ?")),
                         ~ .)
}
```

## English

### Append `"n"` to indefinite article where indicated

```{r}
#' Append `"n"` to indefinite article where indicated
#'
#' Appends an `"n"` to the indefinite article "a" if required by English language rules.
#'
#' Note that this function only covers part of all cases where "an" instead of "a" is indicated. Since the choice of _a_ or _an_ [depends on sound, not 
#' spelling](http://www.butte.edu/departments/cas/tipsheets/grammar/articles.html), it's not trivial to implement a universal solution.
#'
#' For example, this function doesn't properly append an `"n"` to the indefinite article in the following situations:
#' - A word starting with the letter "u" where it is pronounced as a vowel, e.g. _**unhappy**_. Note that most English words starting with letter "u" are
#'   pronounced differently like _universum_ and thus require the indefinite article _a_, not _an_.
#' - A word starting with a consonant that is pronounced as a vowel, e.g. _**hour**_.
#'
#' @param x A character vector.
#'
#' @return A character vector.
#' @family spoken
#' @export
#'
#' @examples
#' n_ify("This is a absolute disaster, such a error.")
n_ify <- function(x) {
  
  purrr::map_chr(.x = x,
                 .f = stringr::str_replace_all,
                 pattern = "(^[Aa]| a)(?= [AaEeOoIi]\\w+)",
                 replacement = "\\1n")
}
```

## German

### Get the German definite article

```{r}
#' Get the German definite article
#'
#' @param gender The grammatical gender of the subject the definite article refers to.
#' @param case The grammatical case of the subject the definite article refers to.
#' @param pluralize Whether to return the plural form of the definite article. A logical scalar.
#'
#' @return A character scalar.
#' @family spoken
#' @export
definite_article_de <- function(gender = c("feminine",
                                           "masculine",
                                           "neuter"),
                                case = c("nominative",
                                         "genitive",
                                         "dative",
                                         "accusative"),
                                pluralize = FALSE) {
  
  gender <- rlang::arg_match(gender)
  case <- rlang::arg_match(case)
  
  if (checkmate::assert_flag(pluralize)) {
    
    switch(EXPR = case,
           nominative = "die",
           genitive = "der",
           dative = "den",
           accusative = "die")
    
  } else {
    
    switch(EXPR = case,
           nominative = switch(EXPR = gender,
                               feminine = "die",
                               masculine = "der",
                               neuter = "das"),
           genitive = switch(EXPR = gender,
                             feminine = "der",
                             "des"),
           dative = switch(EXPR = gender,
                           feminine = "der",
                           "dem"),
           accusative = switch(EXPR = gender,
                               feminine = "die",
                               masculine = "den",
                               neuter = "das"))
  }
}
```

### Decline the German definite article

```{r}
#' Decline the German definite article
#'
#' The declination of the German definite article [is a relative pronoun](https://de.wikipedia.org/wiki/Relativpronomen#Der,_die,_das).
#'
#' Note that the second singular feminine and plural genitive form `"derer"` is ignored by this function.
#'
#' @inheritParams definite_article_de
#'
#' @inherit definite_article_de return
#' @family spoken
#' @export
definite_article_de_declined <- function(gender = c("feminine",
                                                    "masculine",
                                                    "neuter"),
                                         case = c("nominative",
                                                  "genitive",
                                                  "dative",
                                                  "accusative"),
                                         pluralize = FALSE) {
  gender <- rlang::arg_match(gender)
  case <- rlang::arg_match(case)
  
  if (checkmate::assert_flag(pluralize)) {
    
    switch(EXPR = case,
           nominative = "die",
           genitive = "deren",
           dative = "deren",
           accusative = "die")
    
  } else {
    
    switch(EXPR = case,
           nominative = switch(EXPR = gender,
                               feminine = "die",
                               masculine = "der",
                               neuter = "das"),
           genitive = switch(EXPR = gender,
                             feminine = "deren",
                             "dessen"),
           dative = switch(EXPR = gender,
                           feminine = "der",
                           "dem"),
           accusative = switch(EXPR = gender,
                               feminine = "die",
                               masculine = "den",
                               neuter = "das"))
  }
}
```

### Add the German definite article in dative case to a preposition

```{r}
#' Add the German definite article in dative case to a preposition
#'
#' @param preposition The preposition to add the German definite article in dative case to. A character scalar.
#' @param gender The grammatical gender of the `preposition`.
#'
#' @inherit definite_article_de return
#' @family spoken
#' @export
add_definite_article_de <- function(preposition,
                                    gender = c("feminine",
                                               "masculine",
                                               "neuter")) {
  checkmate::assert_string(preposition)
  gender <- rlang::arg_match(gender)
  
  if (gender == "feminine") {
    
    preposition %>% purrr::when(stringr::str_to_lower(.) == "zu" ~ paste0(., "r"),
                                ~ paste0(., " ", definite_article_de(gender = "feminine",
                                                                     case = "dative")))
  } else {
    
    preposition %>% purrr::when(stringr::str_to_lower(.) %in% c("bei", "zu") ~ paste0(., "m"),
                                stringr::str_to_lower(.) %in% c("in", "an") ~ stringr::str_replace(string = .,
                                                                                                   pattern = "n$",
                                                                                                   replacement = "m"),
                                ~ paste0(., " ", definite_article_de(gender = "masculine",
                                                                     case = "dative")))
  }
}
```

### Decline a German noun

```{r}
#' Decline a German noun
#'
#' Note that this function currently doesn't support the [special cases](https://deutsch.lingolia.com/de/grammatik/nomen/deklination/genitiv#a-besonderheiten)
#' where a masculine noun gets an `n` or `en` ending attached in the accusative, dative and genitive cases.
#'
#' @param noun The noun to decline. A character scalar.
#' @param gender The grammatical gender of the `noun`.
#' @param case The grammatical case of the `noun`.
#'
#' @inherit definite_article_de return
#' @family spoken
#' @export
decline_noun_de <- function(noun,
                            gender = c("feminine",
                                       "masculine",
                                       "neuter"),
                            case = c("nominative",
                                     "genitive",
                                     "dative",
                                     "accusative")) {
  
  gender <- rlang::arg_match(gender)
  case <- rlang::arg_match(case)
  result <- noun
  
  if (gender != "feminine" && case == "genitive") {
    
    result %<>% purrr::when(stringr::str_detect(string = ., pattern = "(ss|\U00DF|x|z)$") ~ paste0(., "es"),
                            stringr::str_detect(string = ., pattern = "s$") ~ paste0(., "ses"),
                            ~ paste0(., "s"))
  }
  
  result
}
```

# Pandoc

TODO: Move these fns to dedicated pkg *pndc*?

## Download Pandoc release binaries

```{r}
#' Download Pandoc release binaries
#'
#' Downloads the executable program binaries of a certain Pandoc release for Linux, macOS and Windows.
#'
#' @param os The operating systems for which Pandoc binaries should be downloaded. Any combination of
#'   `r pal::prose_ls_fn_param(param = "os", fn = download_pandoc_binaries, last_separator = " and ")`.
#' @param path The filesystem path to which the binaries are saved to. A [path][fs::fs_path] or something coercible to.
#' @param overwrite Whether to overwrite existing binaries under `path`.
#' @inheritParams pandoc_release_assets
#'
#' @return `path` invisibly.
#' @export
download_pandoc_binaries <- function(release_id = pandoc_release_id_latest(),
                                     os = c("linux", "macos", "windows"),
                                     path = "bin/",
                                     overwrite = TRUE) {
  pal::assert_pkg("zip")
  checkmate::assert_count(release_id,
                          positive = TRUE)
  checkmate::assert_subset(os,
                           choices = eval(formals()$os),
                           empty.ok = FALSE)
  checkmate::assert_path_for_output(path,
                                    overwrite = TRUE)
  checkmate::assert_flag(overwrite)
  
  path_tmp <- fs::path_temp()
  
  assets <-
    pandoc_release_assets(release_id = release_id) %>%
    dplyr::filter(stringr::str_detect(string = filename,
                                      pattern = paste0("(?i)", pal::fuse_regex(os), "(-(amd64|x86_64))?\\.(zip|tar\\.gz)"))) %>%
    dplyr::mutate(download_path = fs::path(path_tmp, filename))
  
  # download assets to tmp dir
  purrr::walk2(.x = assets$download_url,
               .y = assets$download_path,
               .f = utils::download.file,
               method = "auto",
               mode = "wb",
               cacheOK = TRUE,
               quiet = TRUE)
  
  # extract binaries to tmp dir
  assets %>%
    dplyr::select(-download_url) %>%
    as.list() %>%
    purrr::pwalk(.f = function(filename, os, download_path) {
      
      path_os_tmp <- fs::path(path_tmp, "pandoc", os)
      
      # extract all files flat
      if (stringr::str_detect(string = filename,
                              pattern = "\\.zip$")) {
        
        zip::unzip(zipfile = download_path,
                   exdir = path_os_tmp,
                   junkpaths = TRUE)
      } else {
        
        utils::untar(tarfile = download_path,
                     exdir = path_os_tmp)
        
        # since `untar()` has no "junkpaths"-like option, we flatten the dir structure ourselves
        fs::dir_ls(path = path_os_tmp,
                   type = "file",
                   recurse = TRUE,
                   all = TRUE) %>%
          fs::file_move(new_path = path_os_tmp)
      }
      
      # delete archive and all extracted files but the Pandoc binary
      fs::file_delete(download_path)
      
      fs::dir_ls(path = path_os_tmp,
                 regexp = "[\\/]pandoc(\\.exe)?$",
                 all = TRUE,
                 invert = TRUE) %>%
        fs::file_delete()
    })
  
  # move binaries to final dir
  fs::dir_create(path = fs::path(path, "pandoc"))
  
  path_tmp %>%
    fs::path("pandoc") %T>%
    fs::dir_copy(new_path = fs::path(path, "pandoc"),
                 overwrite = overwrite) %>%
    fs::dir_delete()
  
  invisible(path)
}
```

## Get latest Pandoc release ID

```{r}
#' Get latest Pandoc release ID
#'
#' Uses [gh::gh()] to fetch the latest [Pandoc](https://pandoc.org/) release ID via [GitHub's REST
#' API](https://docs.github.com/en/rest/reference/repos#get-the-latest-release).
#'
#' @return An integer scalar.
#' @export
pandoc_release_id_latest <- function() {
  
  pal::assert_pkg("gh")
  
  gh::gh(endpoint = "/repos/{owner}/{repo}/releases/latest",
         owner = "jgm",
         repo = "pandoc",
         .method = "GET") %$%
    id
}
```

## Get latest Pandoc release version number

```{r}
#' Get latest Pandoc release version number
#'
#' Uses [gh::gh()] to fetch the latest [Pandoc](https://pandoc.org/) release version number via [GitHub's REST
#' API](https://docs.github.com/en/rest/reference/repos#get-the-latest-release) and returns it as a [numeric version][numeric_version()].
#'
#' @return `r pkgsnip::param_label("version_nr")`
#' @export
pandoc_version_latest <- function() {
  
  pal::assert_pkg("gh")
  
  gh::gh(endpoint = "/repos/{owner}/{repo}/releases/latest",
         owner = "jgm",
         repo = "pandoc",
         .method = "GET") %$%
    name %>%
    stringr::str_extract(pattern = "\\d+(\\.\\d+)*") %>%
    as.numeric_version()
}
```

## List all available Pandoc releases

```{r}
#' List all available Pandoc releases
#'
#' Uses [gh::gh()] to fetch all available [Pandoc](https://pandoc.org/) releases via [GitHub's REST
#' API](https://docs.github.com/en/rest/reference/repos#list-releases) and returns them as a [tibble][tibble::tbl_df] containing the two columns `version_nr`
#' and `release_id`.
#'
#' Values of the column `release_id` can be used as input to [download_pandoc_binaries()].
#'
#' @return `r pkgsnip::param_label("data")`
#' @export
pandoc_releases <- function() {
  
  pal::assert_pkg("gh")
  
  gh::gh(endpoint = "/repos/{owner}/{repo}/releases",
         owner = "jgm",
         repo = "pandoc",
         .method = "GET",
         .limit = Inf) %>%
    purrr::map_dfr(~ tibble::tibble(version_nr =
                                      .x$name %>%
                                      stringr::str_extract(pattern = "\\d+(\\.\\d+)*") %>%
                                      as.numeric_version(),
                                    release_id = .x$id)) %>%
    dplyr::arrange(version_nr)
}
```

## List Pandoc release assets

```{r}
#' List Pandoc release assets
#'
#' Uses [gh::gh()] to fetch filenames, corresponding operating systems and download URLs of a specific [Pandoc](https://pandoc.org/) release via [GitHub's REST
#' API](https://docs.github.com/en/rest/reference/repos#list-release-assets) and returns them as a [tibble][tibble::tbl_df].
#'
#' @param release_id The GitHub release ID of the desired Pandoc release. Use [pandoc_releases()] to determine the release ID of a specific Pandoc version
#'   number. An integer scalar.
#'
#' @return `r pkgsnip::param_label("data")`
#' @export
pandoc_release_assets <- function(release_id = pandoc_release_id_latest()) {
  
  pal::assert_pkg("gh")
  
  gh::gh(endpoint = "/repos/{owner}/{repo}/releases/{release_id}/assets",
         owner = "jgm",
         repo = "pandoc",
         release_id = release_id,
         .method = "GET") %>%
    purrr::map_dfr(~ tibble::tibble(filename = .x$name,
                                    os =
                                      .x$name %>%
                                      stringr::str_extract(pattern = "(?i)(linux|macos|windows|\\.deb$)") %>%
                                      stringr::str_to_lower() %>%
                                      stringr::str_replace(pattern = "\\.deb",
                                                           replacement = "linux"),
                                    download_url = .x$browser_download_url))
}
```

# Other

## Update Salim B's R packages

```{r}
#' Update [Salim B's R packages](https://gitlab.com/salim_b/r/pkgs)
#'
#' @param pkgs The R pkgs to be updated. A subset of:
#'   `r pal::prose_ls_fn_param(fn = "update_salims_pkgs", param = "pkgs", last_separator = " and ", as_scalar = FALSE) %>% pal::as_md_list()`
#'
#' @return `pkgs`, invisibly.
#' @export
update_salims_pkgs <- function(pkgs = c("c2d4u",
                                        "pal",
                                        "pkgpins",
                                        "pkgpurl",
                                        "pkgsnip",
                                        "rstd",
                                        "salim",
                                        "swissmuni",
                                        "swissparty",
                                        "tocr",
                                        "yay")) {
  pal::assert_pkg("remotes")
  
  checkmate::assert_subset(x = pkgs,
                           choices = as.character(formals()$pkgs)) %>%
    purrr::walk(~ {
      
      if (pal::is_pkg_cran(.x)) {
        utils::install.packages(pkgs = .x,
                                repos = "https://cloud.r-project.org/")
      } else {
        remotes::install_gitlab(repo = paste0("salim_b/r/pkgs/", .x),
                                upgrade = FALSE)
      }
    })
  
  invisible(pkgs)
}
```
